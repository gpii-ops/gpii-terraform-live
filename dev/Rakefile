require 'rake/clean'

task :default => :ci
task :ci => :test

# We need a DNS zone before kops will do anything, so we have to create it in a
# separate terraform run. We use a separate tmpdir so we don't mix up these
# downloaded modules with the main terraform run's downloaded modules.
TMPDIR_PREREQS = File.absolute_path("../rake-prereqs-tmp")

directory TMPDIR_PREREQS
CLOBBER << TMPDIR_PREREQS

rule "#{TMPDIR_PREREQS}/terragrunt" => TMPDIR_PREREQS do
  sh "cd ../k8s-cluster-dns && TMPDIR=#{TMPDIR_PREREQS} terragrunt apply-all --terragrunt-non-interactive"
end
CLEAN << "#{TMPDIR_PREREQS}/terragrunt"

task :teardown_prereqs do
  unless ENV["RAKE_NO_TEARDOWN"]
    sh "cd ../k8s-cluster-dns && TMPDIR=#{TMPDIR_PREREQS} terragrunt destroy-all --terragrunt-non-interactive"
  end
end


TMPDIR = File.absolute_path("../rake-tmp")
ENV["TMPDIR"] = TMPDIR

directory TMPDIR
CLOBBER << TMPDIR

rule "#{TMPDIR}/terragrunt" => [TMPDIR, "#{TMPDIR_PREREQS}/terragrunt"] do
  # Really what we want is get-all, i.e. to download all the modules so we can
  # generate terraform code which we will then run, but that's not a thing.
  # plan-all downloads the modules as a side-effect, so we use that.
  sh "terragrunt plan-all"
end
CLEAN << "#{TMPDIR}/terragrunt"

### RAKEFILES = FileList.new("#{TMPDIR}/terragrunt/**/Rakefile")
RAKEFILES = FileList.new("../../gpii-terraform/modules/**/Rakefile")

task :generate_modules => "#{TMPDIR}/terragrunt" do
  RAKEFILES.each do |rakefile|
    sh "cd #{File.dirname(rakefile)} && rake generate"
  end
end

# This logic duplicates logic on the gpii-terraform-live side. I suspect this
# side will win in the long run, but I'm punting deduplication until the
# design is clearer.
if ENV["TF_VAR_environment"].nil?
  user = ENV["USER"] || "unknown-user"
  ENV["TF_VAR_environment"] = "dev-#{user}"
end
if ENV["TF_VAR_cluster_name"].nil?
  ENV["TF_VAR_cluster_name"] = "k8s-#{ENV["TF_VAR_environment"]}.gpii.net"
end

task :test => :generate_modules do
  sh "bundle exec kitchen create -l debug"
  begin
    sh "bundle exec kitchen converge -l debug"
    puts "Sleeping to allow cluster to settle. This is a hack :/."
    puts
    puts "We must wait for:"
    puts "- the API server to come up and report itself to dns-controller"
    puts "- dns-controller to create api.* A records"
    puts "- A records to propagate so that the local machine can see them"
    puts "(More info: https://github.com/kubernetes/kops/blob/master/docs/boot-sequence.md)"
    puts
    puts "If we look up api.* records too early, local DNS may cache the negative lookup and things will break."
    puts "On my home internet, behind an AirPort, it takes 10 minutes for the bad result to clear and things to work again."
    puts
    sleep_secs = 300
    puts "Sleeping #{sleep_secs}s..."
    sleep sleep_secs
    sh "bundle exec kitchen verify -l debug"
  ensure
    Rake::Task["teardown"].invoke
  end
end

task :teardown do
  unless ENV["RAKE_NO_TEARDOWN"]
    sh "bundle exec kitchen destroy -l debug"
    Rake::Task["teardown_prereqs"].invoke
  end
end

task :clean_modules do
  RAKEFILES.each do |rakefile|
    sh "cd #{File.dirname(rakefile)} && rake clean"
  end
end
Rake::Task["clean"].enhance do
    Rake::Task["clean_modules"].invoke
end

task :clobber_modules do
  RAKEFILES.each do |rakefile|
    sh "cd #{File.dirname(rakefile)} && rake clobber"
  end
end
Rake::Task["clobber"].enhance do
    Rake::Task["clobber_modules"].invoke
end



# vim: ts=2 sw=2:
